(set-info :smt-lib-version 2.6)
(set-info :source |
Generated by: Amar Shah
Generated on: 2024-12-11
Generator: Verus
Application: Verification of Rust Program
Target solver: z3
Time limit: 10
Benchmarks generated by the Rust verifier Verus (https://verus-lang.github.io/verus/guide/) on the project Verismo (https://www.usenix.org/conference/osdi24/presentation/zhou) 
and processed using Mariposa (https://github.com/secure-foundations/mariposa).
This benchmarks was originally run with z3 with the following options:
    (set-option :auto_config false)
    (set-option :smt.mbqi false)
    (set-option :smt.case_split 3)
    (set-option :smt.qi.eager_threshold 100.0)
    (set-option :smt.delay_units true)
    (set-option :smt.arith.solver 2)
    (set-option :smt.arith.nl false)
    (set-option :pi.enabled false)
    (set-option :rewriter.sort_disjunctions false)
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unsat)
(declare-sort %%Function%% 0)
(declare-sort FuelId 0)
(declare-sort Fuel 0)
(declare-const zero Fuel)
(declare-fun succ (Fuel) Fuel)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(declare-sort Char 0)
(declare-fun char%from_unicode (Int) Char)
(declare-fun char%to_unicode (Char) Int)
(declare-sort StrSlice 0)
(declare-fun str%strslice_is_ascii (StrSlice) Bool)
(declare-fun str%strslice_len (StrSlice) Int)
(declare-fun str%strslice_get_char (StrSlice Int) Char)
(declare-fun str%new_strlit (Int) StrSlice)
(declare-fun str%from_strlit (StrSlice) Int)
(declare-datatypes ((fndef 0)) (((fndef_singleton ))))
(declare-sort Poly 0)
(declare-sort Height 0)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun F (fndef) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-fun %F (Poly) fndef)
(declare-fun S (StrSlice) Poly)
(declare-fun %S (Poly) StrSlice)
(declare-fun C (Char) Poly)
(declare-fun %C (Poly) Char)
(declare-sort Type 0)
(declare-const BOOL Type)
(declare-const INT Type)
(declare-const NAT Type)
(declare-const STRSLICE Type)
(declare-const CHAR Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-fun CONST_INT (Int) Type)
(declare-sort Dcr 0)
(declare-const $ Dcr)
(declare-fun REF (Dcr) Dcr)
(declare-fun MUT_REF (Dcr) Dcr)
(declare-fun BOX (Dcr) Dcr)
(declare-fun RC (Dcr) Dcr)
(declare-fun ARC (Dcr) Dcr)
(declare-fun GHOST (Dcr) Dcr)
(declare-fun TRACKED (Dcr) Dcr)
(declare-fun NEVER (Dcr) Dcr)
(declare-fun ARRAY (Dcr Type Dcr Type) Type)
(declare-fun SLICE (Dcr Type) Type)
(declare-fun has_type (Poly Type) Bool)
(declare-fun as_type (Poly Type) Poly)
(declare-fun mk_fun (%%Function%%) %%Function%%)
(declare-fun const_int (Type) Int)
(declare-fun ext_eq (Bool Type Poly Poly) Bool)
(declare-const SZ Int)
(declare-fun uHi (Int) Int)
(declare-fun iLo (Int) Int)
(declare-fun iHi (Int) Int)
(declare-fun nClip (Int) Int)
(declare-fun uClip (Int Int) Int)
(declare-fun iClip (Int Int) Int)
(declare-fun uInv (Int Int) Bool)
(declare-fun iInv (Int Int) Bool)
(declare-fun Add (Int Int) Int)
(declare-fun Sub (Int Int) Int)
(declare-fun height (Poly) Height)
(declare-fun height_lt (Height Height) Bool)
(declare-fun fun_from_recursive_field (Poly) Poly)
(declare-fun check_decrease_int (Int Int Bool) Bool)
(declare-fun check_decrease_height (Poly Poly Bool) Bool)
(declare-fun uintxor (Int Poly Poly) Int)
(declare-fun uintand (Int Poly Poly) Int)
(declare-fun uintor (Int Poly Poly) Int)
(declare-fun uintshr (Int Poly Poly) Int)
(declare-fun uintshl (Int Poly Poly) Int)
(declare-fun uintnot (Int Poly) Int)
(declare-fun singular_mod (Int Int) Int)
(declare-fun closure_req (Type Dcr Type Poly Poly) Bool)
(declare-fun closure_ens (Type Dcr Type Poly Poly Poly) Bool)
(declare-const fuel%vstd!map.impl&%0.spec_index. FuelId)
(declare-const fuel%vstd!set.impl&%0.subset_of. FuelId)
(declare-const fuel%vstd!set.impl&%0.choose. FuelId)
(declare-const fuel%vstd!set.impl&%0.disjoint. FuelId)
(declare-const fuel%verismo!tspec.range_set.range_to_set. FuelId)
(declare-const fuel%verismo!tspec.range_set.range. FuelId)
(declare-const fuel%verismo!tspec.range_set.range2set. FuelId)
(declare-const fuel%verismo!tspec.range_set.impl&%0.to_set. FuelId)
(declare-const fuel%verismo!tspec.range_set.impl&%0.end. FuelId)
(declare-const fuel%verismo!tspec.range_set.within_range. FuelId)
(declare-const fuel%verismo!tspec.range_set.inside_range. FuelId)
(declare-const fuel%verismo!tspec.range_set.inside_ranges. FuelId)
(declare-const fuel%verismo!tspec.range_set.after_range. FuelId)
(declare-const fuel%verismo!tspec.range_set.range_disjoint. FuelId)
(declare-const fuel%verismo!tspec.range_set.range_disjoint_. FuelId)
(declare-const fuel%verismo!tspec.range_set.ranges_disjoint. FuelId)
(declare-sort vstd!set.Set<int.>. 0)
(declare-sort vstd!set.Set<tuple%2<int./nat.>.>. 0)
(declare-datatypes ((tuple%0. 0) (tuple%2. 0)) (((tuple%0./tuple%0 )) ((tuple%2./tuple%2 (tuple%2./tuple%2/?0 Poly) (tuple%2./tuple%2/?1 Poly)))))
(declare-fun tuple%2./tuple%2/0 (tuple%2.) Poly)
(declare-fun tuple%2./tuple%2/1 (tuple%2.) Poly)
(declare-fun TYPE%fun%1. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%vstd!map.Map. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%vstd!set.Set. (Dcr Type) Type)
(declare-const TYPE%tuple%0. Type)
(declare-fun TYPE%tuple%2. (Dcr Type Dcr Type) Type)
(declare-fun Poly%fun%1. (%%Function%%) Poly)
(declare-fun %Poly%fun%1. (Poly) %%Function%%)
(declare-fun Poly%vstd!set.Set<int.>. (vstd!set.Set<int.>.) Poly)
(declare-fun %Poly%vstd!set.Set<int.>. (Poly) vstd!set.Set<int.>.)
(declare-fun Poly%vstd!set.Set<tuple%2<int./nat.>.>. (vstd!set.Set<tuple%2<int./nat.>.>.) Poly)
(declare-fun %Poly%vstd!set.Set<tuple%2<int./nat.>.>. (Poly) vstd!set.Set<tuple%2<int./nat.>.>.)
(declare-fun Poly%tuple%0. (tuple%0.) Poly)
(declare-fun %Poly%tuple%0. (Poly) tuple%0.)
(declare-fun Poly%tuple%2. (tuple%2.) Poly)
(declare-fun %Poly%tuple%2. (Poly) tuple%2.)
(declare-fun %%apply%%0 (%%Function%% Poly) Poly)
(declare-fun tr_bound%verismo!tspec.range_set.VRange. (Dcr Type) Bool)
(declare-fun vstd!map.impl&%0.empty.? (Dcr Type Dcr Type) Poly)
(declare-fun vstd!map.impl&%0.dom.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!map.impl&%0.index.? (Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun vstd!map.impl&%0.spec_index.? (Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun vstd!map.impl&%0.insert.? (Dcr Type Dcr Type Poly Poly Poly) Poly)
(declare-fun vstd!map.impl&%0.remove.? (Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.empty.? (Dcr Type) Poly)
(declare-fun vstd!set.impl&%0.new.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!set.impl&%0.contains.? (Dcr Type Poly Poly) Bool)
(declare-fun vstd!set.impl&%0.subset_of.? (Dcr Type Poly Poly) Bool)
(declare-fun vstd!set.impl&%0.insert.? (Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.remove.? (Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.union.? (Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.intersect.? (Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.difference.? (Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.complement.? (Dcr Type Poly) Poly)
(declare-fun vstd!set.impl&%0.finite.? (Dcr Type Poly) Bool)
(declare-fun vstd!set.impl&%0.len.? (Dcr Type Poly) Int)
(declare-fun vstd!set.impl&%0.choose.? (Dcr Type Poly) Poly)
(declare-fun vstd!set.impl&%0.mk_map.? (Dcr Type Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.disjoint.? (Dcr Type Poly Poly) Bool)
(declare-fun verismo!tspec.range_set.range_to_set.? (Poly Poly) vstd!set.Set<int.>.)
(declare-fun verismo!tspec.range_set.range.? (Poly Poly) tuple%2.)
(declare-fun verismo!tspec.range_set.range2set.? (Poly) vstd!set.Set<int.>.)
(declare-fun verismo!tspec.range_set.VRange.to_set.? (Dcr Type Poly) Poly)
(declare-fun verismo!tspec.range_set.VRange.to_set%default%.? (Dcr Type Poly) Poly)
(declare-fun verismo!tspec.range_set.VRange.end.? (Dcr Type Poly) Poly)
(declare-fun verismo!tspec.range_set.VRange.end%default%.? (Dcr Type Poly) Poly)
(declare-fun verismo!tspec.range_set.within_range.? (Poly Poly) Bool)
(declare-fun verismo!tspec.range_set.inside_range.? (Poly Poly) Bool)
(declare-fun verismo!tspec.range_set.inside_ranges.? (Poly Poly) Bool)
(declare-fun verismo!tspec.range_set.after_range.? (Poly Poly) Bool)
(declare-fun verismo!tspec.range_set.range_disjoint.? (Poly Poly Poly Poly) Bool)
(declare-fun verismo!tspec.range_set.range_disjoint_.? (Poly Poly) Bool)
(declare-fun verismo!tspec.range_set.ranges_disjoint.? (Poly Poly) Bool)
(declare-fun req%vstd!map.impl&%0.index. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%0 Bool)
(declare-fun req%vstd!map.impl&%0.spec_index. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%1 Bool)
(declare-fun req%vstd!map.axiom_map_index_decreases_finite. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%2 Bool)
(declare-const %%global_location_label%%3 Bool)
(declare-fun ens%vstd!map.axiom_map_index_decreases_finite. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-fun req%vstd!map.axiom_map_index_decreases_infinite. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%4 Bool)
(declare-fun ens%vstd!map.axiom_map_index_decreases_infinite. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-fun ens%vstd!map.axiom_map_empty. (Dcr Type Dcr Type) Bool)
(declare-fun ens%vstd!map.axiom_map_insert_domain. (Dcr Type Dcr Type Poly Poly Poly) Bool)
(declare-fun ens%vstd!map.axiom_map_insert_same. (Dcr Type Dcr Type Poly Poly Poly) Bool)
(declare-fun req%vstd!map.axiom_map_insert_different. (Dcr Type Dcr Type Poly Poly Poly Poly) Bool)
(declare-const %%global_location_label%%5 Bool)
(declare-const %%global_location_label%%6 Bool)
(declare-fun ens%vstd!map.axiom_map_insert_different. (Dcr Type Dcr Type Poly Poly Poly Poly) Bool)
(declare-fun ens%vstd!map.axiom_map_remove_domain. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-fun req%vstd!map.axiom_map_remove_different. (Dcr Type Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%7 Bool)
(declare-const %%global_location_label%%8 Bool)
(declare-fun ens%vstd!map.axiom_map_remove_different. (Dcr Type Dcr Type Poly Poly Poly) Bool)
(declare-fun ens%vstd!map.axiom_map_ext_equal. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-fun ens%vstd!map.axiom_map_ext_equal_deep. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-fun ens%vstd!set.axiom_set_empty. (Dcr Type Poly) Bool)
(declare-fun ens%vstd!set.axiom_set_new. (Dcr Type %%Function%% Poly) Bool)
(declare-fun ens%vstd!set.axiom_set_insert_same. (Dcr Type Poly Poly) Bool)
(declare-fun req%vstd!set.axiom_set_insert_different. (Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%9 Bool)
(declare-fun ens%vstd!set.axiom_set_insert_different. (Dcr Type Poly Poly Poly) Bool)
(declare-fun ens%vstd!set.axiom_set_remove_same. (Dcr Type Poly Poly) Bool)
(declare-fun req%vstd!set.axiom_set_remove_insert. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%10 Bool)
(declare-fun ens%vstd!set.axiom_set_remove_insert. (Dcr Type Poly Poly) Bool)
(declare-fun req%vstd!set.axiom_set_remove_different. (Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%11 Bool)
(declare-fun ens%vstd!set.axiom_set_remove_different. (Dcr Type Poly Poly Poly) Bool)
(declare-fun ens%vstd!set.axiom_set_union. (Dcr Type Poly Poly Poly) Bool)
(declare-fun ens%vstd!set.axiom_set_intersect. (Dcr Type Poly Poly Poly) Bool)
(declare-fun ens%vstd!set.axiom_set_difference. (Dcr Type Poly Poly Poly) Bool)
(declare-fun ens%vstd!set.axiom_set_complement. (Dcr Type Poly Poly) Bool)
(declare-fun ens%vstd!set.axiom_set_ext_equal. (Dcr Type Poly Poly) Bool)
(declare-fun ens%vstd!set.axiom_set_ext_equal_deep. (Dcr Type Poly Poly) Bool)
(declare-fun ens%vstd!set.axiom_mk_map_domain. (Dcr Type Dcr Type Poly %%Function%%) Bool)
(declare-fun req%vstd!set.axiom_mk_map_index. (Dcr Type Dcr Type Poly %%Function%% Poly) Bool)
(declare-const %%global_location_label%%12 Bool)
(declare-fun ens%vstd!set.axiom_mk_map_index. (Dcr Type Dcr Type Poly %%Function%% Poly) Bool)
(declare-fun ens%vstd!set.axiom_set_empty_finite. (Dcr Type) Bool)
(declare-fun req%vstd!set.axiom_set_insert_finite. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%13 Bool)
(declare-fun ens%vstd!set.axiom_set_insert_finite. (Dcr Type Poly Poly) Bool)
(declare-fun req%vstd!set.axiom_set_remove_finite. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%14 Bool)
(declare-fun ens%vstd!set.axiom_set_remove_finite. (Dcr Type Poly Poly) Bool)
(declare-fun req%vstd!set.axiom_set_union_finite. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%15 Bool)
(declare-const %%global_location_label%%16 Bool)
(declare-fun ens%vstd!set.axiom_set_union_finite. (Dcr Type Poly Poly) Bool)
(declare-fun req%vstd!set.axiom_set_intersect_finite. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%17 Bool)
(declare-fun ens%vstd!set.axiom_set_intersect_finite. (Dcr Type Poly Poly) Bool)
(declare-fun req%vstd!set.axiom_set_difference_finite. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%18 Bool)
(declare-fun ens%vstd!set.axiom_set_difference_finite. (Dcr Type Poly Poly) Bool)
(declare-fun %%choose%%0 (Type Dcr Type Poly Dcr Type Poly) Poly)
(declare-fun req%vstd!set.axiom_set_choose_finite. (Dcr Type Poly) Bool)
(declare-const %%global_location_label%%19 Bool)
(declare-fun ens%vstd!set.axiom_set_choose_finite. (Dcr Type Poly) Bool)
(declare-fun ens%vstd!set.axiom_set_empty_len. (Dcr Type) Bool)
(declare-fun req%vstd!set.axiom_set_insert_len. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%20 Bool)
(declare-fun ens%vstd!set.axiom_set_insert_len. (Dcr Type Poly Poly) Bool)
(declare-fun req%vstd!set.axiom_set_remove_len. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%21 Bool)
(declare-fun ens%vstd!set.axiom_set_remove_len. (Dcr Type Poly Poly) Bool)
(declare-fun req%vstd!set.axiom_set_contains_len. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%22 Bool)
(declare-const %%global_location_label%%23 Bool)
(declare-fun ens%vstd!set.axiom_set_contains_len. (Dcr Type Poly Poly) Bool)
(declare-fun req%vstd!set.axiom_set_choose_len. (Dcr Type Poly) Bool)
(declare-const %%global_location_label%%24 Bool)
(declare-const %%global_location_label%%25 Bool)
(declare-fun ens%vstd!set.axiom_set_choose_len. (Dcr Type Poly) Bool)
(declare-fun %%lambda%%0 (Int Int) %%Function%%)
(declare-fun ens%verismo!tspec.range_set.lemma_to_set. (Int Int vstd!set.Set<int.>.) Bool)
(declare-fun ens%verismo!tspec.range_set.lemma_range_set_disjoint. (Int Int Int Int Bool) Bool)
(declare-fun ens%verismo!tspec.range_set.proof_range_set_disjoint. (tuple%2. tuple%2. Bool) Bool)
(declare-fun req%verismo!tspec.range_set.lemma_ranges_disjoint_insert. (tuple%2. tuple%2. vstd!set.Set<tuple%2<int./nat.>.>.) Bool)
(declare-const %%global_location_label%%26 Bool)
(declare-fun ens%verismo!tspec.range_set.lemma_ranges_disjoint_insert. (tuple%2. tuple%2. vstd!set.Set<tuple%2<int./nat.>.>.) Bool)
(declare-fun req%verismo!tspec.range_set.lemma_range_set_low_high. (Int Int Int) Bool)
(declare-const %%global_location_label%%27 Bool)
(declare-fun ens%verismo!tspec.range_set.lemma_range_set_low_high. (Int Int Int) Bool)
(declare-fun ens%verismo!tspec.setlib.lemma_union. (Dcr Type Poly Poly) Bool)
(declare-fun ens%verismo!tspec.range_set.proof_union_auto. (Dcr Type) Bool)
(declare-const int&. Dcr)
(declare-const int& Type)
(declare-const s1@ Poly)
(declare-const s2@ Poly)
(declare-const s3@ Poly)
(declare-const a@ Poly)
(declare-const s1$1@ Poly)
(declare-const s2$1@ Poly)
(declare-const s1$2@ Poly)
(declare-const s2$2@ Poly)
(declare-const s1$3@ Poly)
(declare-const s2$3@ Poly)
(declare-const a$1@ Poly)
(declare-const %%location_label%%0 Bool)
(declare-const %%location_label%%1 Bool)
(declare-const %%location_label%%2 Bool)
(declare-const %%location_label%%3 Bool)
(declare-const %%location_label%%4 Bool)
(declare-const %%location_label%%5 Bool)
(declare-const %%location_label%%6 Bool)
(declare-const %%location_label%%7 Bool)
(declare-const %%location_label%%8 Bool)
(declare-const %%location_label%%9 Bool)

;(assert (forall ((id FuelId)) (! (= (fuel_bool id) (fuel_bool_default id)) :pattern ((fuel_bool id)) )))
(assert (forall ((deep Bool) (t Type) (x Poly) (y Poly)) (! (= (= x y) (ext_eq deep t x y)) :pattern ((ext_eq deep t x y)) )))
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (s2! Poly)) (! (= (vstd!set.impl&%0.subset_of.? A&. A& self! s2!) (forall ((a$ Poly)) (! (=> (has_type a$ A&) (=> (vstd!set.impl&%0.contains.? A&. A& self! a$) (vstd!set.impl&%0.contains.? A&. A& s2! a$))) :pattern ((vstd!set.impl&%0.contains.? A&. A& self! a$)) :pattern ((vstd!set.impl&%0.contains.? A&. A& s2! a$)) ))) :pattern ((vstd!set.impl&%0.subset_of.? A&. A& self! s2!)) )))
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (s2! Poly)) (! (=> (and (has_type self! (TYPE%vstd!set.Set. A&. A&)) (has_type s2! (TYPE%vstd!set.Set. A&. A&))) (has_type (vstd!set.impl&%0.union.? A&. A& self! s2!) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.union.? A&. A& self! s2!)) )))
(assert (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly) (a! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!set.Set. A&. A&)) (has_type s2! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.union.? A&. A& s1! s2!) a!) (or (vstd!set.impl&%0.contains.? A&. A& s1! a!) (vstd!set.impl&%0.contains.? A&. A& s2! a!)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.union.? A&. A& s1! s2!) a!)) )))
(assert (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!set.Set. A&. A&)) (has_type s2! (TYPE%vstd!set.Set. A&. A&))) (= (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!) (forall ((a$ Poly)) (! (=> (has_type a$ A&) (= (vstd!set.impl&%0.contains.? A&. A& s1! a$) (vstd!set.impl&%0.contains.? A&. A& s2! a$))) :pattern ((vstd!set.impl&%0.contains.? A&. A& s1! a$)) :pattern ((vstd!set.impl&%0.contains.? A&. A& s2! a$)) )))) :pattern ((ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!)) )))
(assert (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!set.Set. A&. A&)) (has_type s2! (TYPE%vstd!set.Set. A&. A&))) (= (ext_eq true (TYPE%vstd!set.Set. A&. A&) s1! s2!) (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!))) :pattern ((ext_eq true (TYPE%vstd!set.Set. A&. A&) s1! s2!)) )))
(assert (not (and (=> (has_type s1@ (TYPE%vstd!set.Set. int&. int&)) (=> (has_type s2@ (TYPE%vstd!set.Set. int&. int&)) (=> (has_type s3@ (TYPE%vstd!set.Set. int&. int&)) (and (=> (has_type a@ int&) (=> %%location_label%%0 (= (vstd!set.impl&%0.contains.? int&. int& (vstd!set.impl&%0.union.? int&. int& (vstd!set.impl&%0.union.? int&. int& s1@ s2@) s3@) a@) (vstd!set.impl&%0.contains.? int&. int& (vstd!set.impl&%0.union.? int&. int& s1@ (vstd!set.impl&%0.union.? int&. int& s2@ s3@)) a@)))) (=> (forall ((a$ Poly)) (! (=> (has_type a$ int&) (= (vstd!set.impl&%0.contains.? int&. int& (vstd!set.impl&%0.union.? int&. int& (vstd!set.impl&%0.union.? int&. int& s1@ s2@) s3@) a$) (vstd!set.impl&%0.contains.? int&. int& (vstd!set.impl&%0.union.? int&. int& s1@ (vstd!set.impl&%0.union.? int&. int& s2@ s3@)) a$))) :pattern ((vstd!set.impl&%0.contains.? int&. int& (vstd!set.impl&%0.union.? int&. int& (vstd!set.impl&%0.union.? int&. int& s1@ s2@) s3@) a$)) :pattern ((vstd!set.impl&%0.contains.? int&. int& (vstd!set.impl&%0.union.? int&. int& s1@ (vstd!set.impl&%0.union.? int&. int& s2@ s3@)) a$)) )) (=> %%location_label%%1 (ext_eq true (TYPE%vstd!set.Set. int&. int&) (vstd!set.impl&%0.union.? int&. int& (vstd!set.impl&%0.union.? int&. int& s1@ s2@) s3@) (vstd!set.impl&%0.union.? int&. int& s1@ (vstd!set.impl&%0.union.? int&. int& s2@ s3@))))))))) (=> (forall ((s1$ Poly) (s2$ Poly) (s3$ Poly)) (! (=> (and (has_type s1$ (TYPE%vstd!set.Set. int&. int&)) (has_type s2$ (TYPE%vstd!set.Set. int&. int&)) (has_type s3$ (TYPE%vstd!set.Set. int&. int&))) (ext_eq true (TYPE%vstd!set.Set. int&. int&) (vstd!set.impl&%0.union.? int&. int& (vstd!set.impl&%0.union.? int&. int& s1$ s2$) s3$) (vstd!set.impl&%0.union.? int&. int& s1$ (vstd!set.impl&%0.union.? int&. int& s2$ s3$)))) :pattern ((vstd!set.impl&%0.union.? int&. int& (vstd!set.impl&%0.union.? int&. int& s1$ s2$) s3$)) :pattern ((vstd!set.impl&%0.union.? int&. int& s1$ (vstd!set.impl&%0.union.? int&. int& s2$ s3$))) )) (and (=> (has_type s1$1@ (TYPE%vstd!set.Set. int&. int&)) (=> (has_type s2$1@ (TYPE%vstd!set.Set. int&. int&)) (=> (ens%verismo!tspec.setlib.lemma_union. int&. int& s1$1@ s2$1@) (=> %%location_label%%2 (ext_eq true (TYPE%vstd!set.Set. int&. int&) (vstd!set.impl&%0.union.? int&. int& s1$1@ s2$1@) (vstd!set.impl&%0.union.? int&. int& s2$1@ s1$1@)))))) (=> (forall ((s1$ Poly) (s2$ Poly)) (! (=> (and (has_type s1$ (TYPE%vstd!set.Set. int&. int&)) (has_type s2$ (TYPE%vstd!set.Set. int&. int&))) (ext_eq true (TYPE%vstd!set.Set. int&. int&) (vstd!set.impl&%0.union.? int&. int& s1$ s2$) (vstd!set.impl&%0.union.? int&. int& s2$ s1$))) :pattern ((vstd!set.impl&%0.union.? int&. int& s1$ s2$)) :pattern ((vstd!set.impl&%0.union.? int&. int& s2$ s1$)) )) (and (=> (has_type s1$2@ (TYPE%vstd!set.Set. int&. int&)) (=> (has_type s2$2@ (TYPE%vstd!set.Set. int&. int&)) (=> (ens%verismo!tspec.setlib.lemma_union. int&. int& s1$2@ s2$2@) (=> %%location_label%%3 (vstd!set.impl&%0.subset_of.? int&. int& s1$2@ (vstd!set.impl&%0.union.? int&. int& s1$2@ s2$2@)))))) (=> (forall ((s1$ Poly) (s2$ Poly)) (! (=> (and (has_type s1$ (TYPE%vstd!set.Set. int&. int&)) (has_type s2$ (TYPE%vstd!set.Set. int&. int&))) (vstd!set.impl&%0.subset_of.? int&. int& s1$ (vstd!set.impl&%0.union.? int&. int& s1$ s2$))) :pattern ((vstd!set.impl&%0.union.? int&. int& s1$ s2$)) )) (and (=> (has_type s1$3@ (TYPE%vstd!set.Set. int&. int&)) (=> (has_type s2$3@ (TYPE%vstd!set.Set. int&. int&)) (=> (vstd!set.impl&%0.subset_of.? int&. int& s2$3@ s1$3@) (and (=> (has_type a$1@ int&) (=> %%location_label%%4 (= (vstd!set.impl&%0.contains.? int&. int& (vstd!set.impl&%0.union.? int&. int& s1$3@ s2$3@) a$1@) (vstd!set.impl&%0.contains.? int&. int& s1$3@ a$1@)))) (=> (forall ((a$ Poly)) (! (=> (has_type a$ int&) (= (vstd!set.impl&%0.contains.? int&. int& (vstd!set.impl&%0.union.? int&. int& s1$3@ s2$3@) a$) (vstd!set.impl&%0.contains.? int&. int& s1$3@ a$))) :pattern ((vstd!set.impl&%0.contains.? int&. int& s1$3@ a$)) )) (=> %%location_label%%5 (ext_eq true (TYPE%vstd!set.Set. int&. int&) (vstd!set.impl&%0.union.? int&. int& s1$3@ s2$3@) s1$3@))))))) (=> (forall ((s1$ Poly) (s2$ Poly)) (! (=> (and (has_type s1$ (TYPE%vstd!set.Set. int&. int&)) (has_type s2$ (TYPE%vstd!set.Set. int&. int&))) (=> (vstd!set.impl&%0.subset_of.? int&. int& s2$ s1$) (ext_eq true (TYPE%vstd!set.Set. int&. int&) (vstd!set.impl&%0.union.? int&. int& s1$ s2$) s1$))) :pattern ((vstd!set.impl&%0.subset_of.? int&. int& s2$ s1$)) :pattern ((vstd!set.impl&%0.union.? int&. int& s1$ s2$)) )) (and (=> %%location_label%%6 (forall ((s1$ Poly) (s2$ Poly) (s3$ Poly)) (! (=> (and (has_type s1$ (TYPE%vstd!set.Set. int&. int&)) (has_type s2$ (TYPE%vstd!set.Set. int&. int&)) (has_type s3$ (TYPE%vstd!set.Set. int&. int&))) (= (vstd!set.impl&%0.union.? int&. int& (vstd!set.impl&%0.union.? int&. int& s1$ s2$) s3$) (vstd!set.impl&%0.union.? int&. int& s1$ (vstd!set.impl&%0.union.? int&. int& s2$ s3$)))) :pattern ((vstd!set.impl&%0.union.? int&. int& (vstd!set.impl&%0.union.? int&. int& s1$ s2$) s3$)) :pattern ((vstd!set.impl&%0.union.? int&. int& s1$ (vstd!set.impl&%0.union.? int&. int& s2$ s3$))) ))) (and (=> %%location_label%%7 (forall ((s1$ Poly) (s2$ Poly)) (! (=> (and (has_type s1$ (TYPE%vstd!set.Set. int&. int&)) (has_type s2$ (TYPE%vstd!set.Set. int&. int&))) (= (vstd!set.impl&%0.union.? int&. int& s1$ s2$) (vstd!set.impl&%0.union.? int&. int& s2$ s1$))) :pattern ((vstd!set.impl&%0.union.? int&. int& s1$ s2$)) :pattern ((vstd!set.impl&%0.union.? int&. int& s2$ s1$)) ))) (and (=> %%location_label%%8 (forall ((s1$ Poly) (s2$ Poly)) (! (=> (and (has_type s1$ (TYPE%vstd!set.Set. int&. int&)) (has_type s2$ (TYPE%vstd!set.Set. int&. int&))) (vstd!set.impl&%0.subset_of.? int&. int& s1$ (vstd!set.impl&%0.union.? int&. int& s1$ s2$))) :pattern ((vstd!set.impl&%0.union.? int&. int& s1$ s2$)) ))) (=> %%location_label%%9 (forall ((s1$ Poly) (s2$ Poly)) (! (=> (and (has_type s1$ (TYPE%vstd!set.Set. int&. int&)) (has_type s2$ (TYPE%vstd!set.Set. int&. int&))) (=> (vstd!set.impl&%0.subset_of.? int&. int& s2$ s1$) (= (vstd!set.impl&%0.union.? int&. int& s1$ s2$) s1$))) :pattern ((vstd!set.impl&%0.subset_of.? int&. int& s2$ s1$)) :pattern ((vstd!set.impl&%0.union.? int&. int& s1$ s2$)) ))))))))))))))))

(check-sat)
